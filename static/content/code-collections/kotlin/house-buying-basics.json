{
  "id": "house-buying-basics",
  "name": "Kotlin House Buying Basics",
  "description": "Learn Kotlin programming with real estate and home buying themes",
  "icon": "üè†",
  "difficulty": "beginner",
  "language": "kotlin",
  "snippets": [
    {
      "code": "val houseAddress = \"123 Oak Street\"\nval bedrooms = 3\nvar listingPrice = 325000.0\nvar isAvailable = true\n\nprintln(\"Property: $houseAddress\")\nprintln(\"Bedrooms: $bedrooms\")\nprintln(\"Listing Price: $$listingPrice\")\nprintln(\"Available: $isAvailable\")",
      "title": "House Listing Variables",
      "description": "Basic Kotlin variables and string templates for property data",
      "tags": ["val", "var", "println", "string-templates"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "fun calculateMortgagePayment(principal: Double, annualRate: Double, years: Int): Double {\n    val monthlyRate = annualRate / 12 / 100\n    val payments = years * 12\n    return principal * (monthlyRate * Math.pow(1 + monthlyRate, payments.toDouble())) / \n           (Math.pow(1 + monthlyRate, payments.toDouble()) - 1)\n}\n\nfun formatCurrency(amount: Double): String {\n    return \"$%.2f\".format(amount)\n}\n\nval homePrice = 280000.0\nval downPayment = homePrice * 0.20\nval loanAmount = homePrice - downPayment\nval monthlyPayment = calculateMortgagePayment(loanAmount, 4.5, 30)\n\nprintln(\"Home Price: ${formatCurrency(homePrice)}\")\nprintln(\"Down Payment: ${formatCurrency(downPayment)}\")\nprintln(\"Monthly Payment: ${formatCurrency(monthlyPayment)}\")",
      "title": "Mortgage Calculator Functions",
      "description": "Functions for calculating home financing costs",
      "tags": ["functions", "calculations", "math", "formatting"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "enum class PropertyType {\n    HOUSE,\n    CONDO,\n    TOWNHOUSE,\n    APARTMENT\n}\n\nenum class PropertyStatus {\n    FOR_SALE,\n    UNDER_CONTRACT,\n    PENDING,\n    SOLD,\n    OFF_MARKET\n}\n\nval propertyType = PropertyType.HOUSE\nval status = PropertyStatus.FOR_SALE\n\nwhen (propertyType) {\n    PropertyType.HOUSE -> println(\"Single family home\")\n    PropertyType.CONDO -> println(\"Condominium unit\")\n    PropertyType.TOWNHOUSE -> println(\"Townhome property\")\n    PropertyType.APARTMENT -> println(\"Apartment unit\")\n}\n\nprintln(\"Current status: ${status.name.lowercase().replace('_', ' ')}\")",
      "title": "Property Types and Status",
      "description": "Enums and when expressions for property classification",
      "tags": ["enum", "when", "string-manipulation"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "data class House(\n    val address: String,\n    val bedrooms: Int,\n    val bathrooms: Double,\n    val squareFeet: Int,\n    val price: Double,\n    val yearBuilt: Int\n) {\n    fun getPricePerSquareFoot(): Double = price / squareFeet\n    \n    fun getAgeInYears(): Int = 2024 - yearBuilt\n    \n    fun isAffordable(maxBudget: Double): Boolean = price <= maxBudget\n}\n\nval dreamHouse = House(\n    address = \"456 Maple Avenue\",\n    bedrooms = 4,\n    bathrooms = 2.5,\n    squareFeet = 2200,\n    price = 375000.0,\n    yearBuilt = 2018\n)\n\nprintln(\"House: ${dreamHouse.address}\")\nprintln(\"Price per sq ft: $${\"%.2f\".format(dreamHouse.getPricePerSquareFoot())}\")\nprintln(\"Age: ${dreamHouse.getAgeInYears()} years\")\nprintln(\"Affordable (budget $400k): ${dreamHouse.isAffordable(400000.0)}\")",
      "title": "House Data Class",
      "description": "Data classes with methods for property information",
      "tags": ["data-class", "methods", "properties"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "val neighborhoods = listOf(\n    \"Downtown\", \"Suburbs\", \"Waterfront\", \"Historic District\", \"New Development\"\n)\n\nval housePrices = listOf(450000.0, 320000.0, 680000.0, 275000.0, 395000.0)\n\nprintln(\"Available Neighborhoods:\")\nfor ((index, neighborhood) in neighborhoods.withIndex()) {\n    println(\"${index + 1}. $neighborhood - Average: $${\"%.0f\".format(housePrices[index])}\")\n}\n\nval affordableOptions = neighborhoods.zip(housePrices).filter { it.second < 400000 }\nprintln(\"\\nAffordable options (under $400k):\")\naffordableOptions.forEach { (name, price) ->\n    println(\"$name - $${\"%.0f\".format(price)}\")\n}",
      "title": "Neighborhood Listings",
      "description": "Lists, loops, and functional operations for area analysis",
      "tags": ["lists", "withIndex", "zip", "filter"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "val propertyFeatures = mapOf(\n    \"pool\" to \"Swimming Pool\",\n    \"garage\" to \"2-Car Garage\",\n    \"fireplace\" to \"Wood Burning Fireplace\",\n    \"deck\" to \"Large Deck\",\n    \"basement\" to \"Finished Basement\"\n)\n\nval houseFeatures = setOf(\"pool\", \"garage\", \"fireplace\")\n\nprintln(\"This house includes:\")\nfor (feature in houseFeatures) {\n    val description = propertyFeatures[feature] ?: \"Unknown feature\"\n    println(\"‚úì $description\")\n}\n\nval allFeatures = propertyFeatures.keys\nval missingFeatures = allFeatures - houseFeatures\nprintln(\"\\nMissing features: ${missingFeatures.joinToString(\", \")}\")",
      "title": "Property Features Map",
      "description": "Maps, sets, and null safety for feature tracking",
      "tags": ["map", "set", "elvis-operator", "set-operations"],
      "difficulty": "beginner",
      "language": "kotlin"
    },
    {
      "code": "fun validateBuyerInfo(name: String?, creditScore: Int?, income: Double?): String {\n    return when {\n        name.isNullOrBlank() -> \"Name is required\"\n        creditScore == null || creditScore < 600 -> \"Credit score must be 600 or higher\"\n        income == null || income < 50000 -> \"Minimum income of $50,000 required\"\n        else -> \"Buyer qualification approved\"\n    }\n}\n\nfun calculateMaxLoanAmount(income: Double, creditScore: Int): Double {\n    val baseMultiplier = when {\n        creditScore >= 750 -> 5.0\n        creditScore >= 700 -> 4.5\n        creditScore >= 650 -> 4.0\n        else -> 3.5\n    }\n    return income * baseMultiplier\n}\n\nval buyer1 = validateBuyerInfo(\"John Smith\", 720, 75000.0)\nval buyer2 = validateBuyerInfo(\"\", 680, 45000.0)\n\nprintln(buyer1)\nprintln(buyer2)\n\nif (buyer1.contains(\"approved\")) {\n    val maxLoan = calculateMaxLoanAmount(75000.0, 720)\n    println(\"Maximum loan amount: $${\"%.0f\".format(maxLoan)}\")\n}",
      "title": "Buyer Qualification System",
      "description": "Null safety and conditional logic for loan processing",
      "tags": ["null-safety", "when-conditions", "validation"],
      "difficulty": "intermediate",
      "language": "kotlin"
    },
    {
      "code": "class RealEstateAgent(\n    private val name: String,\n    private val licenseNumber: String\n) {\n    private val clientList = mutableListOf<String>()\n    private var totalSales = 0.0\n    \n    fun addClient(clientName: String) {\n        clientList.add(clientName)\n        println(\"$name added $clientName as a client\")\n    }\n    \n    fun recordSale(saleAmount: Double, clientName: String) {\n        if (clientList.contains(clientName)) {\n            totalSales += saleAmount\n            println(\"Sale recorded: $clientName - $${\"%.0f\".format(saleAmount)}\")\n        } else {\n            println(\"$clientName is not a registered client\")\n        }\n    }\n    \n    fun getStats(): Pair<Int, Double> = clientList.size to totalSales\n    \n    override fun toString(): String {\n        val (clients, sales) = getStats()\n        return \"Agent: $name (License: $licenseNumber)\\nClients: $clients, Total Sales: $${\"%.0f\".format(sales)}\"\n    }\n}\n\nval agent = RealEstateAgent(\"Sarah Johnson\", \"RE-12345\")\nagent.addClient(\"Mike Wilson\")\nagent.addClient(\"Lisa Chen\")\nagent.recordSale(325000.0, \"Mike Wilson\")\nagent.recordSale(280000.0, \"Lisa Chen\")\nprintln(agent.toString())",
      "title": "Real Estate Agent Class",
      "description": "Classes with encapsulation and business logic",
      "tags": ["class", "private", "mutableList", "override"],
      "difficulty": "intermediate",
      "language": "kotlin"
    },
    {
      "code": "interface PropertySearchable {\n    fun searchByPrice(minPrice: Double, maxPrice: Double): List<House>\n    fun searchByBedrooms(bedrooms: Int): List<House>\n    fun searchByNeighborhood(neighborhood: String): List<House>\n}\n\nclass PropertyDatabase : PropertySearchable {\n    private val properties = mutableListOf<House>()\n    \n    fun addProperty(house: House) {\n        properties.add(house)\n    }\n    \n    override fun searchByPrice(minPrice: Double, maxPrice: Double): List<House> {\n        return properties.filter { it.price in minPrice..maxPrice }\n    }\n    \n    override fun searchByBedrooms(bedrooms: Int): List<House> {\n        return properties.filter { it.bedrooms == bedrooms }\n    }\n    \n    override fun searchByNeighborhood(neighborhood: String): List<House> {\n        return properties.filter { it.address.contains(neighborhood, ignoreCase = true) }\n    }\n    \n    fun getAveragePrice(): Double {\n        return if (properties.isNotEmpty()) {\n            properties.map { it.price }.average()\n        } else 0.0\n    }\n}\n\nval database = PropertyDatabase()\ndatabase.addProperty(House(\"123 Oak St\", 3, 2.0, 1800, 295000.0, 2015))\ndatabase.addProperty(House(\"456 Pine Ave\", 4, 3.0, 2400, 425000.0, 2020))\n\nval affordableHomes = database.searchByPrice(250000.0, 350000.0)\nprintln(\"Affordable homes found: ${affordableHomes.size}\")\naffordableHomes.forEach { println(\"${it.address} - $${\"%.0f\".format(it.price)}\") }",
      "title": "Property Search Interface",
      "description": "Interfaces and implementation with search functionality",
      "tags": ["interface", "override", "range", "filter"],
      "difficulty": "intermediate",
      "language": "kotlin"
    },
    {
      "code": "sealed class InspectionResult {\n    object Passed : InspectionResult()\n    data class Failed(val issues: List<String>) : InspectionResult()\n    data class ConditionalPass(val minorIssues: List<String>, val repairCost: Double) : InspectionResult()\n}\n\nfun processInspection(result: InspectionResult): String {\n    return when (result) {\n        is InspectionResult.Passed -> {\n            \"‚úÖ Inspection passed! Ready to proceed with purchase.\"\n        }\n        is InspectionResult.Failed -> {\n            \"‚ùå Inspection failed. Major issues found:\\n\" +\n            result.issues.joinToString(\"\\n\") { \"‚Ä¢ $it\" }\n        }\n        is InspectionResult.ConditionalPass -> {\n            \"‚ö†Ô∏è Conditional pass. Minor issues (Est. cost: $${\"%.0f\".format(result.repairCost)}):\\n\" +\n            result.minorIssues.joinToString(\"\\n\") { \"‚Ä¢ $it\" }\n        }\n    }\n}\n\nval inspection1 = InspectionResult.Passed\nval inspection2 = InspectionResult.Failed(listOf(\"Foundation cracks\", \"Roof leaks\", \"Electrical issues\"))\nval inspection3 = InspectionResult.ConditionalPass(\n    listOf(\"Loose door handle\", \"Squeaky floor\"), \n    350.0\n)\n\nprintln(processInspection(inspection1))\nprintln()\nprintln(processInspection(inspection2))\nprintln()\nprintln(processInspection(inspection3))",
      "title": "Home Inspection Results",
      "description": "Sealed classes for type-safe result handling",
      "tags": ["sealed-class", "when-expression", "data-class"],
      "difficulty": "intermediate",
      "language": "kotlin"
    },
    {
      "code": "class MortgageCalculator {\n    companion object {\n        const val DEFAULT_TERM_YEARS = 30\n        const val DEFAULT_DOWN_PAYMENT_PERCENT = 0.20\n        \n        fun calculateAffordability(income: Double, monthlyDebts: Double, interestRate: Double): Double {\n            val maxMonthlyPayment = (income / 12) * 0.28 - monthlyDebts\n            val monthlyRate = interestRate / 12 / 100\n            val payments = DEFAULT_TERM_YEARS * 12\n            \n            return if (maxMonthlyPayment > 0) {\n                maxMonthlyPayment * (Math.pow(1 + monthlyRate, payments.toDouble()) - 1) /\n                (monthlyRate * Math.pow(1 + monthlyRate, payments.toDouble()))\n            } else 0.0\n        }\n    }\n    \n    fun generateAmortizationPreview(principal: Double, rate: Double, years: Int = DEFAULT_TERM_YEARS): List<String> {\n        val monthlyRate = rate / 12 / 100\n        val payments = years * 12\n        val monthlyPayment = principal * (monthlyRate * Math.pow(1 + monthlyRate, payments.toDouble())) / \n                           (Math.pow(1 + monthlyRate, payments.toDouble()) - 1)\n        \n        var balance = principal\n        val schedule = mutableListOf<String>()\n        \n        for (month in 1..12) { // First year preview\n            val interestPayment = balance * monthlyRate\n            val principalPayment = monthlyPayment - interestPayment\n            balance -= principalPayment\n            \n            schedule.add(\"Month $month: Principal $${\"%.2f\".format(principalPayment)}, \" +\n                        \"Interest $${\"%.2f\".format(interestPayment)}, \" +\n                        \"Balance $${\"%.0f\".format(balance)}\")\n        }\n        \n        return schedule\n    }\n}\n\nval calculator = MortgageCalculator()\nval affordableAmount = MortgageCalculator.calculateAffordability(85000.0, 1200.0, 4.25)\nprintln(\"Maximum affordable loan: $${\"%.0f\".format(affordableAmount)}\")\n\nprintln(\"\\nFirst year payment breakdown:\")\nval schedule = calculator.generateAmortizationPreview(300000.0, 4.25)\nschedule.take(3).forEach { println(it) }\nprintln(\"... (showing first 3 months)\")",
      "title": "Advanced Mortgage Calculator",
      "description": "Companion objects and complex financial calculations",
      "tags": ["companion-object", "const", "complex-calculations"],
      "difficulty": "advanced",
      "language": "kotlin"
    },
    {
      "code": "data class PropertyListing(\n    val house: House,\n    val agent: String,\n    val listingDate: String,\n    val features: Set<String>\n)\n\nclass PropertyMatcher {\n    private val listings = mutableListOf<PropertyListing>()\n    \n    fun addListing(listing: PropertyListing) {\n        listings.add(listing)\n    }\n    \n    fun findMatches(\n        priceRange: ClosedRange<Double>,\n        minBedrooms: Int,\n        requiredFeatures: Set<String> = emptySet(),\n        excludeFeatures: Set<String> = emptySet()\n    ): List<PropertyListing> {\n        return listings.filter { listing ->\n            listing.house.price in priceRange &&\n            listing.house.bedrooms >= minBedrooms &&\n            listing.features.containsAll(requiredFeatures) &&\n            listing.features.intersect(excludeFeatures).isEmpty()\n        }\n    }\n    \n    fun getBestMatches(criteria: SearchCriteria): List<Pair<PropertyListing, Int>> {\n        return listings.map { listing ->\n            val score = calculateMatchScore(listing, criteria)\n            listing to score\n        }.filter { it.second > 0 }.sortedByDescending { it.second }\n    }\n    \n    private fun calculateMatchScore(listing: PropertyListing, criteria: SearchCriteria): Int {\n        var score = 0\n        \n        // Price score (closer to target = higher score)\n        val priceDiff = Math.abs(listing.house.price - criteria.targetPrice) / criteria.targetPrice\n        score += ((1.0 - priceDiff) * 100).toInt().coerceAtLeast(0)\n        \n        // Feature matches\n        val featureMatches = listing.features.intersect(criteria.desiredFeatures).size\n        score += featureMatches * 20\n        \n        // Bedroom match\n        if (listing.house.bedrooms == criteria.idealBedrooms) score += 30\n        \n        return score\n    }\n}\n\ndata class SearchCriteria(\n    val targetPrice: Double,\n    val idealBedrooms: Int,\n    val desiredFeatures: Set<String>\n)\n\nval matcher = PropertyMatcher()\nval criteria = SearchCriteria(350000.0, 3, setOf(\"garage\", \"pool\"))\n\n// Add sample listings\nval house1 = House(\"123 Main St\", 3, 2.0, 1900, 340000.0, 2018)\nval listing1 = PropertyListing(house1, \"Jane Doe\", \"2024-01-15\", setOf(\"garage\", \"fireplace\"))\nmatcher.addListing(listing1)\n\nval matches = matcher.getBestMatches(criteria)\nif (matches.isNotEmpty()) {\n    println(\"Best match (Score: ${matches.first().second}):\")\n    println(matches.first().first.house.address)\n}",
      "title": "Smart Property Matching",
      "description": "Complex algorithms with scoring and filtering systems",
      "tags": ["algorithms", "scoring", "closedrange", "sortedby"],
      "difficulty": "advanced",
      "language": "kotlin"
    },
    {
      "code": "typealias PriceCalculator = (Double, Double, Int) -> Double\ntypealias PropertyFilter = (House) -> Boolean\n\nclass MarketAnalyzer {\n    private val priceHistories = mutableMapOf<String, MutableList<Double>>()\n    \n    fun addPricePoint(address: String, price: Double) {\n        priceHistories.getOrPut(address) { mutableListOf() }.add(price)\n    }\n    \n    fun analyzeMarket(properties: List<House>): MarketReport {\n        val totalProperties = properties.size\n        val averagePrice = properties.map { it.price }.average()\n        val priceRanges = mapOf(\n            \"Under $300k\" to properties.count { it.price < 300000 },\n            \"$300k-$500k\" to properties.count { it.price in 300000.0..500000.0 },\n            \"Over $500k\" to properties.count { it.price > 500000 }\n        )\n        \n        val trendAnalysis = priceHistories.mapValues { (address, prices) ->\n            if (prices.size >= 2) {\n                val trend = ((prices.last() - prices.first()) / prices.first()) * 100\n                when {\n                    trend > 10 -> \"Rising significantly (+${\"%.1f\".format(trend)}%)\"\n                    trend > 2 -> \"Rising moderately (+${\"%.1f\".format(trend)}%)\"\n                    trend < -10 -> \"Declining significantly (${\"%.1f\".format(trend)}%)\"\n                    trend < -2 -> \"Declining moderately (${\"%.1f\".format(trend)}%)\"\n                    else -> \"Stable (${\"%.1f\".format(trend)}%)\"\n                }\n            } else \"Insufficient data\"\n        }\n        \n        return MarketReport(totalProperties, averagePrice, priceRanges, trendAnalysis)\n    }\n    \n    fun applyCustomAnalysis(properties: List<House>, filter: PropertyFilter, calculator: PriceCalculator): Double {\n        val filteredProperties = properties.filter(filter)\n        return if (filteredProperties.isNotEmpty()) {\n            filteredProperties.map { house ->\n                calculator(house.price, house.squareFeet.toDouble(), house.getAgeInYears())\n            }.average()\n        } else 0.0\n    }\n}\n\ndata class MarketReport(\n    val totalProperties: Int,\n    val averagePrice: Double,\n    val priceDistribution: Map<String, Int>,\n    val trends: Map<String, String>\n)\n\n// Extension function for House\nfun House.getAgeInYears(): Int = 2024 - this.yearBuilt\n\nval analyzer = MarketAnalyzer()\nval sampleProperties = listOf(\n    House(\"123 Oak St\", 3, 2.0, 1800, 295000.0, 2015),\n    House(\"456 Pine Ave\", 4, 3.0, 2400, 425000.0, 2020),\n    House(\"789 Elm Dr\", 2, 1.5, 1200, 225000.0, 2010)\n)\n\nval report = analyzer.analyzeMarket(sampleProperties)\nprintln(\"Market Analysis Report:\")\nprintln(\"Total Properties: ${report.totalProperties}\")\nprintln(\"Average Price: $${\"%.0f\".format(report.averagePrice)}\")\nreport.priceDistribution.forEach { (range, count) ->\n    println(\"$range: $count properties\")\n}\n\n// Custom analysis using type aliases\nval luxuryFilter: PropertyFilter = { it.price > 400000 }\nval pricePerSqFt: PriceCalculator = { price, sqft, _ -> price / sqft }\nval avgLuxuryPricePerSqFt = analyzer.applyCustomAnalysis(sampleProperties, luxuryFilter, pricePerSqFt)\nprintln(\"\\nLuxury homes avg price per sq ft: $${\"%.2f\".format(avgLuxuryPricePerSqFt)}\")",
      "title": "Market Analysis with Type Aliases",
      "description": "Advanced types and functional programming for market analysis",
      "tags": ["typealias", "higher-order-functions", "extension-functions"],
      "difficulty": "advanced",
      "language": "kotlin"
    },
    {
      "code": "class PropertyTransaction {\n    private val steps = mutableListOf<TransactionStep>()\n    private var currentStep = 0\n    \n    init {\n        steps.addAll(listOf(\n            TransactionStep(\"Initial Offer\", false),\n            TransactionStep(\"Offer Accepted\", false),\n            TransactionStep(\"Home Inspection\", false),\n            TransactionStep(\"Appraisal\", false),\n            TransactionStep(\"Loan Approval\", false),\n            TransactionStep(\"Final Walkthrough\", false),\n            TransactionStep(\"Closing\", false)\n        ))\n    }\n    \n    fun completeCurrentStep(): Boolean {\n        return if (currentStep < steps.size) {\n            steps[currentStep] = steps[currentStep].copy(completed = true)\n            println(\"‚úÖ Completed: ${steps[currentStep].name}\")\n            currentStep++\n            true\n        } else {\n            println(\"All steps completed!\")\n            false\n        }\n    }\n    \n    fun getProgress(): Pair<Int, Int> = currentStep to steps.size\n    \n    fun getProgressPercentage(): Double = (currentStep.toDouble() / steps.size) * 100\n    \n    fun getRemainingSteps(): List<TransactionStep> {\n        return steps.drop(currentStep)\n    }\n    \n    fun generateProgressReport(): String {\n        val (completed, total) = getProgress()\n        val percentage = getProgressPercentage()\n        \n        return buildString {\n            appendLine(\"üè† Home Purchase Progress Report\")\n            appendLine(\"Progress: $completed/$total steps (${\"%.1f\".format(percentage)}%)\")\n            appendLine()\n            \n            appendLine(\"Completed Steps:\")\n            steps.take(currentStep).forEach {\n                appendLine(\"‚úÖ ${it.name}\")\n            }\n            \n            if (currentStep < steps.size) {\n                appendLine(\"\\nNext Step: ${steps[currentStep].name}\")\n                \n                val remaining = getRemainingSteps()\n                if (remaining.size > 1) {\n                    appendLine(\"\\nRemaining Steps:\")\n                    remaining.drop(1).forEach {\n                        appendLine(\"‚è≥ ${it.name}\")\n                    }\n                }\n            } else {\n                appendLine(\"\\nüéâ Congratulations! Home purchase complete!\")\n            }\n        }\n    }\n}\n\ndata class TransactionStep(val name: String, val completed: Boolean)\n\nval transaction = PropertyTransaction()\n\n// Simulate transaction progress\nrepeat(3) {\n    transaction.completeCurrentStep()\n}\n\nprintln(transaction.generateProgressReport())\n\nval (completed, total) = transaction.getProgress()\nprintln(\"\\nQuick status: $completed out of $total steps completed\")",
      "title": "Transaction Progress Tracker",
      "description": "Complex state management with progress tracking and reporting",
      "tags": ["state-management", "buildString", "repeat", "copy"],
      "difficulty": "advanced",
      "language": "kotlin"
    },
    {
      "code": "@Target(AnnotationTarget.PROPERTY)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class PropertyFeature(val displayName: String, val priority: Int = 0)\n\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.RUNTIME)\nannotation class ListingInfo(val category: String, val featured: Boolean = false)\n\n@ListingInfo(category = \"Residential\", featured = true)\ndata class PremiumListing(\n    @PropertyFeature(\"Street Address\", priority = 1)\n    val address: String,\n    \n    @PropertyFeature(\"Asking Price\", priority = 2)\n    val price: Double,\n    \n    @PropertyFeature(\"Number of Bedrooms\", priority = 3)\n    val bedrooms: Int,\n    \n    @PropertyFeature(\"Swimming Pool\")\n    val hasPool: Boolean = false,\n    \n    @PropertyFeature(\"Attached Garage\")\n    val hasGarage: Boolean = false,\n    \n    @PropertyFeature(\"Square Footage\")\n    val squareFeet: Int\n) {\n    companion object {\n        inline fun <reified T> getPropertyFeatures(): List<Pair<String, Int>> {\n            return T::class.java.declaredFields.mapNotNull { field ->\n                field.getAnnotation(PropertyFeature::class.java)?.let {\n                    it.displayName to it.priority\n                }\n            }.sortedByDescending { it.second }\n        }\n        \n        inline fun <reified T> getListingCategory(): String? {\n            return T::class.java.getAnnotation(ListingInfo::class.java)?.category\n        }\n    }\n    \n    fun generateFeatureList(): String {\n        val features = mutableListOf<String>()\n        \n        if (hasPool) features.add(\"Swimming Pool\")\n        if (hasGarage) features.add(\"Attached Garage\")\n        features.add(\"$squareFeet sq ft\")\n        features.add(\"$bedrooms bedrooms\")\n        \n        return features.joinToString(\", \")\n    }\n}\n\nval listing = PremiumListing(\n    address = \"789 Luxury Lane\",\n    price = 750000.0,\n    bedrooms = 4,\n    hasPool = true,\n    hasGarage = true,\n    squareFeet = 3200\n)\n\nprintln(\"Premium Listing Details:\")\nprintln(\"Address: ${listing.address}\")\nprintln(\"Price: $${\"%.0f\".format(listing.price)}\")\nprintln(\"Features: ${listing.generateFeatureList()}\")\nprintln(\"Category: ${PremiumListing.getListingCategory<PremiumListing>()}\")\n\nprintln(\"\\nProperty Features (by priority):\")\nPremiumListing.getPropertyFeatures<PremiumListing>().forEach { (name, priority) ->\n    if (priority > 0) println(\"$priority. $name\") else println(\"‚Ä¢ $name\")\n}",
      "title": "Advanced Listing with Annotations",
      "description": "Annotations and reflection for metadata-driven property listings",
      "tags": ["annotations", "reflection", "inline-reified"],
      "difficulty": "advanced",
      "language": "kotlin"
    },
    {
      "code": "import kotlinx.coroutines.*\nimport kotlin.system.measureTimeMillis\n\nclass AsyncPropertyService {\n    \n    suspend fun fetchPropertyDetails(address: String): PropertyDetails {\n        delay(1000) // Simulate API call\n        return PropertyDetails(\n            address = address,\n            price = (200000..800000).random().toDouble(),\n            bedrooms = (1..5).random(),\n            bathrooms = listOf(1.0, 1.5, 2.0, 2.5, 3.0).random(),\n            squareFeet = (800..4000).random(),\n            yearBuilt = (1990..2023).random()\n        )\n    }\n    \n    suspend fun getMarketComparables(address: String): List<PropertyDetails> {\n        delay(1500) // Simulate longer API call\n        return (1..5).map {\n            PropertyDetails(\n                address = \"${(100..999).random()} ${listOf(\"Oak\", \"Pine\", \"Elm\", \"Maple\")[it % 4]} St\",\n                price = (250000..600000).random().toDouble(),\n                bedrooms = (2..4).random(),\n                bathrooms = listOf(1.5, 2.0, 2.5).random(),\n                squareFeet = (1200..2800).random(),\n                yearBuilt = (2000..2023).random()\n            )\n        }\n    }\n    \n    suspend fun checkPropertyHistory(address: String): PropertyHistory {\n        delay(800) // Simulate database query\n        return PropertyHistory(\n            previousSales = (1..3).map {\n                SaleRecord(\n                    date = \"202${(0..3).random()}-0${(1..9).random()}-${(10..28).random()}\",\n                    price = (180000..550000).random().toDouble()\n                )\n            }.sortedByDescending { it.date }\n        )\n    }\n}\n\ndata class PropertyDetails(\n    val address: String,\n    val price: Double,\n    val bedrooms: Int,\n    val bathrooms: Double,\n    val squareFeet: Int,\n    val yearBuilt: Int\n)\n\ndata class PropertyHistory(val previousSales: List<SaleRecord>)\ndata class SaleRecord(val date: String, val price: Double)\n\nsuspend fun generatePropertyReport(address: String) {\n    val service = AsyncPropertyService()\n    \n    println(\"üè† Generating comprehensive property report for: $address\")\n    println(\"‚è≥ Fetching data from multiple sources...\\n\")\n    \n    val executionTime = measureTimeMillis {\n        // Run all API calls concurrently\n        val propertyDetailsDeferred = async { service.fetchPropertyDetails(address) }\n        val comparablesDeferred = async { service.getMarketComparables(address) }\n        val historyDeferred = async { service.checkPropertyHistory(address) }\n        \n        // Wait for all results\n        val property = propertyDetailsDeferred.await()\n        val comparables = comparablesDeferred.await()\n        val history = historyDeferred.await()\n        \n        // Generate report\n        println(\"üìä PROPERTY ANALYSIS REPORT\")\n        println(\"=\" * 40)\n        println(\"Property: ${property.address}\")\n        println(\"Current Price: $${\"%.0f\".format(property.price)}\")\n        println(\"Specs: ${property.bedrooms} bed, ${property.bathrooms} bath, ${property.squareFeet} sq ft\")\n        println(\"Built: ${property.yearBuilt}\")\n        \n        println(\"\\nüìà COMPARABLE SALES:\")\n        val avgComparablePrice = comparables.map { it.price }.average()\n        comparables.take(3).forEach {\n            println(\"${it.address}: $${\"%.0f\".format(it.price)} (${it.bedrooms}/${it.bathrooms}/${it.squareFeet})\")\n        }\n        println(\"Average comparable price: $${\"%.0f\".format(avgComparablePrice)}\")\n        \n        println(\"\\nüìã SALES HISTORY:\")\n        history.previousSales.forEach {\n            println(\"${it.date}: $${\"%.0f\".format(it.price)}\")\n        }\n        \n        val priceVsMarket = ((property.price - avgComparablePrice) / avgComparablePrice) * 100\n        println(\"\\nüí° ANALYSIS:\")\n        println(\"Price vs Market: ${if (priceVsMarket > 0) \"+\" else \"\"}${\"%.1f\".format(priceVsMarket)}%\")\n        println(\"Recommendation: ${if (priceVsMarket < -5) \"Good deal!\" else if (priceVsMarket > 10) \"Overpriced\" else \"Fair market value\"}\")\n    }\n    \n    println(\"\\n‚ö° Report generated in ${executionTime}ms\")\n}\n\n// Extension function\noperator fun String.times(n: Int) = repeat(n)\n\n// Run the async property report\nrunBlocking {\n    generatePropertyReport(\"123 Dream Home Lane\")\n}",
      "title": "Async Property Research System",
      "description": "Coroutines and async programming for real estate data processing",
      "tags": ["coroutines", "async-await", "runBlocking", "concurrent"],
      "difficulty": "advanced",
      "language": "kotlin"
    }
  ]
}